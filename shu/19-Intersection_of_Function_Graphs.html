<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Intersection of Function Graphs</title>
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 750px;
    }
    #box {
      width: 700px;
      height: 450px;
      border: 1px solid #ccc;
      margin-bottom: 15px;
    }
    .controls {
      margin-bottom: 10px;
    }
    label {
      margin-right: 8px;
      font-weight: bold;
    }
    input[type=range] {
      vertical-align: middle;
      width: 250px;
    }
    span.value {
      display: inline-block;
      width: 40px;
      text-align: center;
      font-weight: bold;
      color: #0066cc;
    }
    #explanation {
      background-color: #eef6fb;
      border-left: 4px solid #2196F3;
      padding: 12px 20px;
      margin-bottom: 20px;
      font-size: 0.95em;
      line-height: 1.5;
      color: #333;
    }
  </style>
</head>
<body>

  <h2>Intersection of Function Graphs</h2>

  <div id="explanation">
    <strong>Concept Explanation:</strong><br />
    This graph shows two functions:<br />
    \( f(x) = x^2 \) (a quadratic function) and <br />
    \( g(x) = m \cdot x + c \) (a linear function).<br />
    You can adjust the slope \( m \) and intercept \( c \) of the linear function using the sliders.<br />
    The points where the two graphs intersect represent the solutions to the equation \( x^2 = m \cdot x + c \).
  </div>

  <div id="box"></div>

  <div class="controls">
    <label for="mRange">Slope (m): </label>
    <input type="range" id="mRange" min="-3" max="3" step="0.1" value="2" />
    <span class="value" id="mVal">2.0</span>
  </div>

  <div class="controls">
    <label for="cRange">Intercept (c): </label>
    <input type="range" id="cRange" min="-5" max="5" step="0.1" value="1" />
    <span class="value" id="cVal">1.0</span>
  </div>

<script>
  const board = JXG.JSXGraph.initBoard('box', {
    boundingbox: [-5, 15, 5, -5],
    axis: true,
    showNavigation: false,
    zoom: { wheel: false },
    pan: { enabled: false }
  });

  // Functions f(x) = x^2, g(x) = m*x + c (initial values)
  let m = 2, c = 1;

  function f(x) {
    return x*x;
  }
  function g(x) {
    return m*x + c;
  }

  // Plot functions
  let fGraph = board.create('functiongraph', [f], {strokeColor: 'blue', strokeWidth: 3, name: 'f(x) = x²', withLabel:true, label:{offset:[10,10]}});
  let gGraph = board.create('functiongraph', [g], {strokeColor: 'red', strokeWidth: 3, name: 'g(x) = m·x + c', withLabel:true, label:{offset:[10,-15]}});

  // Intersection points storage
  let intersections = [];

  // Function to find and show intersections
  function updateIntersections() {
    // Remove old intersection points
    intersections.forEach(pt => board.removeObject(pt));
    intersections = [];

    // We search for intersection points by scanning x values
    // Then refine roots with a numeric method (Newton or bisection).
    // Here we do a simple scan with step and check sign changes for f(x)-g(x).
    let points = [];
    let xMin = -5, xMax = 5, step = 0.01;

    function h(x) {
      return f(x) - g(x);
    }

    let prevX = xMin;
    let prevY = h(prevX);

    for (let x = xMin + step; x <= xMax; x += step) {
      let y = h(x);
      if (prevY * y <= 0) {
        // There is a root between prevX and x, approximate it by bisection
        let root = findRootBisection(h, prevX, x, 1e-7, 20);
        if (root !== null) {
          points.push(root);
        }
      }
      prevX = x;
      prevY = y;
    }

    // Add intersection points to the board
    points.forEach(xVal => {
      let yVal = f(xVal);
      let pt = board.create('point', [xVal, yVal], {
        name: '',
        size: 4,
        color: 'green',
        fixed: true,
        highlight: true,
        withLabel: false
      });
      intersections.push(pt);
    });
  }

  // Bisection method to find root of function fn in [a,b]
  function findRootBisection(fn, a, b, tol=1e-7, maxIter=50) {
    let fa = fn(a);
    let fb = fn(b);
    if (fa * fb > 0) return null; // no root in [a,b]

    let c = a;
    for (let i=0; i < maxIter; i++) {
      c = (a + b) / 2;
      let fc = fn(c);
      if (Math.abs(fc) < tol) return c;
      if (fa * fc < 0) {
        b = c; fb = fc;
      } else {
        a = c; fa = fc;
      }
    }
    return c;
  }

  // Update functions and intersections based on slider values
  function update() {
    m = parseFloat(document.getElementById('mRange').value);
    c = parseFloat(document.getElementById('cRange').value);
    document.getElementById('mVal').textContent = m.toFixed(1);
    document.getElementById('cVal').textContent = c.toFixed(1);

    // Update linear function g graph
    gGraph.Y = function(x) { return m*x + c; };
    board.update();
    updateIntersections();
    board.update();
  }

  // Attach listeners
  document.getElementById('mRange').addEventListener('input', update);
  document.getElementById('cRange').addEventListener('input', update);

  // Initial call
  update();
</script>

</body>
</html>
